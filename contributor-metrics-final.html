<!DOCTYPE html>
<html lang="ta">
<head>
<meta charset="UTF-8">
<title>à®µà®¿à®•à¯à®•à®¿à®¤à¯ à®¤à®¿à®Ÿà¯à®Ÿà®®à¯ à®†à®¯à¯à®µà®¿ â€“ Complete & Bugâ€‘Fixed</title>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body { font-family: sans-serif; padding: 20px; }
h2, h3 { margin-top: 25px; }
input, button { padding: 6px; margin: 5px; }
.badge { font-weight: bold; }
table { border-collapse: collapse; margin-top: 10px; }
th, td { border: 1px solid #999; padding: 6px 10px; text-align: center; }
th { background: #f0f0f0; }
ul { list-style: none; padding-left: 0; }
li { margin: 4px 0; }
.section { border-top: 3px solid #ccc; padding-top: 15px; margin-top: 20px; }
.note { background:#fff8dc; padding:10px; margin-top:10px; }
</style>
</head>

<body>

<h2>ğŸ“Š à®µà®¿à®•à¯à®•à®¿à®¤à¯ à®¤à®¿à®Ÿà¯à®Ÿà®®à¯ à®†à®¯à¯à®µà®¿</h2>

<input type="text" id="username" placeholder="Wikimedia User name">
<button onclick="analyze()">Analyze</button>
<button onclick="exportJSON()">â¬‡ï¸ JSON</button>
<button onclick="exportCSV()">â¬‡ï¸ CSV</button>

<div id="global" class="section"></div>
<div id="quality" class="section"></div>

<canvas id="colorChart" height="160"></canvas>
<canvas id="trendChart" height="200"></canvas>

<script>
/* ================= CONFIG ================= */
const META = "https://meta.wikimedia.org/w/api.php?origin=*";
const WS   = "https://ta.wikisource.org/w/api.php?origin=*";
let FINAL_DATA = {};

/* ================= MAIN ================= */
async function analyze() {
  const user = document.getElementById("username").value.trim();
  if (!user) return alert("à®ªà®¯à®©à®°à¯ à®ªà¯†à®¯à®°à¯ à®‡à®Ÿà®µà¯à®®à¯");

  document.getElementById("global").innerHTML = "â³ Global profile loading...";
  document.getElementById("quality").innerHTML = "â³ Wikisource quality loading...";

  /* SECTION A â€“ Global */
  const global = await getGlobalProfile(user);
  renderGlobal(global, user);

  /* SECTION B â€“ Quality */
  const edits = await getWikisourceEdits(user);
  const colors = await getColorStats(edits);
  const metrics = calculateMetrics(edits.length, colors);
  const trends = getMonthlyTrends(edits);

  renderQuality(edits.length, colors, metrics);
  renderCharts(colors, trends);

  FINAL_DATA = {
    user,
    global,
    quality: {
      analyzed_edits: edits.length,
      colors,
      metrics,
      trends
    }
  };
}

/* ================= GLOBAL PROFILE ================= */
async function getGlobalProfile(user) {
  const url =
    `${META}&action=query&meta=globaluserinfo` +
    `&guiuser=${encodeURIComponent(user)}` +
    `&guiprop=editcount|merged|registration&format=json`;

  const data = await fetch(url).then(r => r.json());
  return data.query.globaluserinfo;
}

function renderGlobal(info, user) {
  let rows = "";
  info.merged
    .filter(m => m.editcount > 0)
    .sort((a,b)=>b.editcount-a.editcount)
    .forEach(m=>{
      rows += `<tr><td>${m.wiki}</td><td>${m.editcount}</td></tr>`;
    });

  document.getElementById("global").innerHTML = `
    <h3>ğŸŒ Global Contribution Profile</h3>
    <p class="badge">ğŸ‘¤ ${user}</p>
    <p>âœï¸ Global edits: <b>${info.editcount}</b></p>
    <p>ğŸ—“ï¸ Registered: ${info.registration}</p>
    <p>ğŸ”— Attached projects: ${info.merged.length}</p>

    <table>
      <tr><th>Project</th><th>Lifetime edits</th></tr>
      ${rows}
    </table>
  `;
}

/* ================= WIKISOURCE EDITS ================= */
async function getWikisourceEdits(user) {
  let edits = [], cont = "";
  do {
    const url =
      `${WS}&action=query&list=usercontribs` +
      `&ucuser=${encodeURIComponent(user)}` +
      `&ucnamespace=104&uclimit=50&format=json` +
      (cont ? `&uccontinue=${cont}` : "");

    const d = await fetch(url).then(r=>r.json());
    if (d.query?.usercontribs)
      edits = edits.concat(d.query.usercontribs);

    cont = d.continue?.uccontinue;
  } while (cont && edits.length < 200);

  return edits;
}

/* ================= COLOR STATS (BUG FIXED) ================= */
async function getColorStats(edits) {
  const ids = [...new Set(edits.map(e => e.pageid))];
  let c = { red:0, yellow:0, purple:0, green:0 };

  for (let id of ids) {
    const url =
      `${WS}&action=query&prop=proofread&pageids=${id}&format=json`;

    const d = await fetch(url).then(r=>r.json());
    const p = d.query.pages[id];
    if (!p || p.proofread === undefined) continue;

    switch (p.proofread.level) {
      case 0: c.red++; break;
      case 1: c.yellow++; break;
      case 2: c.purple++; break;
      case 3: c.green++; break;
    }
  }
  return c;
}

/* ================= METRICS ================= */
function calculateMetrics(total, c) {
  const score =
    ((c.yellow + c.green) / total) * 40 +
    (c.green / total) * 40 +
    Math.min(total / 50, 1) * 20;

  const level =
    score < 25 ? "Learner" :
    score < 50 ? "Contributor" :
    score < 75 ? "Skilled Editor" :
    score < 90 ? "Expert" :
    "Mentorâ€‘ready";

  return { score: Math.round(score), level };
}

/* ================= TRENDS ================= */
function getMonthlyTrends(edits) {
  const t = {};
  edits.forEach(e => {
    const m = e.timestamp.slice(0,7);
    t[m] = (t[m] || 0) + 1;
  });
  return t;
}

/* ================= RENDER QUALITY ================= */
function renderQuality(n, c, m) {
  document.getElementById("quality").innerHTML = `
    <h3>ğŸ“˜ Wikisource Quality Analysis</h3>
    <div class="note">
      âš ï¸ Analysis based on <b>last ${n} Page edits</b>
    </div>

    <p>âœï¸ Analyzed edits: ${n}</p>
    <ul>
      <li style="color:red">ğŸ”´ Red: ${c.red}</li>
      <li style="color:goldenrod">ğŸŸ¡ Yellow: ${c.yellow}</li>
      <li style="color:purple">ğŸŸ£ Purple: ${c.purple}</li>
      <li style="color:green">ğŸŸ¢ Green: ${c.green}</li>
    </ul>

    <p class="badge">â­ Quality Score: ${m.score} / 100</p>
    <p class="badge">ğŸ… Contributor Level: ${m.level}</p>
  `;
}

/* ================= CHARTS ================= */
function renderCharts(c, t) {
  new Chart(colorChart, {
    type:"pie",
    data:{
      labels:["Red","Yellow","Purple","Green"],
      datasets:[{
        data:[c.red,c.yellow,c.purple,c.green],
        backgroundColor:["red","gold","purple","green"]
      }]
    }
  });

  new Chart(trendChart,{
    type:"bar",
    data:{
      labels:Object.keys(t),
      datasets:[{
        label:"Edits",
        data:Object.values(t),
        backgroundColor:"#4CAF50"
      }]
    }
  });
}

/* ================= EXPORT ================= */
function exportJSON(){
  download(JSON.stringify(FINAL_DATA,null,2),"metrics.json","application/json");
}
function exportCSV(){
  const q = FINAL_DATA.quality;
  const rows = [
    ["Metric","Value"],
    ["Analyzed edits", q.analyzed_edits],
    ["Red", q.colors.red],
    ["Yellow", q.colors.yellow],
    ["Purple", q.colors.purple],
    ["Green", q.colors.green],
    ["Score", q.metrics.score],
    ["Level", q.metrics.level]
  ];
  download(rows.map(r=>r.join(",")).join("\n"),"metrics.csv","text/csv");
}
function download(data,name,type){
  const a=document.createElement("a");
  a.href=URL.createObjectURL(new Blob([data],{type}));
  a.download=name;
  a.click();
}
</script>

</body>
</html>
